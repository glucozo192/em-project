package internal

import (
	"fmt"
	"regexp"
	"runtime/debug"
	"strings"

	"github.com/common-nighthawk/go-figure"
	options "google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

type generator struct {
	f             *protogen.File
	p             *protogen.Plugin
	protoServices []*descriptorpb.ServiceDescriptorProto
}

func normalizeFullname(fn protoreflect.FullName) string {
	return strings.ReplaceAll(string(fn), ".", "_")
}

func (g *generator) GenerateMethods() {
	req := g.p.Request
	filename := g.f.GeneratedFilenamePrefix + "_methods.pb.go"
	genFile := g.p.NewGeneratedFile(filename, g.f.GoImportPath)
	fName := string(g.f.Desc.Name())
	custom := figure.NewFigure("custom", "", true)
	compilerVersion := "unknown"
	if v := req.GetCompilerVersion(); v != nil {
		compilerVersion = fmt.Sprintf("%d.%d.%d", v.GetMajor(), v.GetMinor(), v.GetPatch())
	}
	genFile.P("/* *")
	genFile.P(custom.String())
	genFile.P("*/")
	genFile.P("// * Code generated by protoc-gen-custom. DO NOT EDIT.")
	genFile.P("// * versions:")
	genFile.P("// * - protoc-gen-custom ", GetVersion(debug.ReadBuildInfo))
	genFile.P("// * - protoc                   v", compilerVersion)
	genFile.P("// * source: ", fName)
	genFile.P("")
	genFile.P("package ", g.f.GoPackageName)
	genFile.P("const (")
	for _, s := range g.f.Services {
		for _, m := range s.Methods {
			methodName := normalizeFullname(protoreflect.FullName(s.Desc.Name())) + "_" + string(m.Desc.Name())
			genFile.P("\t", methodName, ` = "/`, s.Desc.FullName(), "/", m.Desc.Name(), `"`)
		}
	}
	genFile.P(")")
}

func (g *generator) GenerateEnums() {
	req := g.p.Request
	filename := g.f.GeneratedFilenamePrefix + "_enums.pb.go"
	genFile := g.p.NewGeneratedFile(filename, g.f.GoImportPath)
	fName := string(g.f.Desc.Name())
	custom := figure.NewFigure("custom", "", true)

	compilerVersion := "unknown"
	if v := req.GetCompilerVersion(); v != nil {
		compilerVersion = fmt.Sprintf("%d.%d.%d", v.GetMajor(), v.GetMinor(), v.GetPatch())
	}
	genFile.P("/*")
	genFile.P(custom.String())
	genFile.P("*/")
	genFile.P("// * Code generated by protoc-gen-custom. DO NOT EDIT.")
	genFile.P("// * versions:")
	genFile.P("// * - protoc-gen-custom ", GetVersion(debug.ReadBuildInfo))
	genFile.P("// * - protoc                   v", compilerVersion)
	genFile.P("// * source: ", fName)
	genFile.P("")
	genFile.P("package ", g.f.GoPackageName)

	genFile.P("")
	for _, e := range g.f.Enums {
		name := e.Desc.Name()

		genFile.P("func (x ", name, ") FromString(str string) ", name, " {")
		genFile.P("\tswitch str {")
		for _, val := range e.Values {
			enumName := val.GoIdent.GoName
			genFile.P("\t\tcase ", enumName, ".String():")
			genFile.P("\t\t\treturn ", enumName)
		}
		genFile.P("\t}")
		genFile.P("\treturn ", name, "(0)")
		genFile.P("}\n")
	}
}

type BuildInfoReaderFunc = func() (*debug.BuildInfo, bool)

func GetVersion(infoReader BuildInfoReaderFunc) string {
	info, ok := infoReader()
	if !ok || info.Main.Version == "" {
		return "(unknown)"
	}
	return info.Main.Version
}

func Run(opt protogen.Options) {
	opt.Run(func(p *protogen.Plugin) error {
		p.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		g := generator{}
		for _, f := range p.Files {
			if !f.Generate {
				continue
			}

			g.f = f
			g.p = p
			g.protoServices = append(g.protoServices, g.f.Proto.Service...)
			g.GeneratePbMethods()
			g.GenerateEnums()
		}
		g.GenerateAllAPIs()
		//g.GenerateCayCu()
		return nil
	})
}

func (g *generator) GenerateAllAPIs() {
	req := g.p.Request
	folderStructure := strings.Split(g.f.GeneratedFilenamePrefix, "/")
	folderStructure[len(folderStructure)-1] = "all_in_one.pb.go"
	filename := strings.Join(folderStructure, "/")

	genFile := g.p.NewGeneratedFile(filename, g.f.GoImportPath)
	fName := string(g.f.Desc.Name())
	custom := figure.NewFigure("custom", "", true)
	compilerVersion := "unknown"
	if v := req.GetCompilerVersion(); v != nil {
		compilerVersion = fmt.Sprintf("%d.%d.%d", v.GetMajor(), v.GetMinor(), v.GetPatch())
	}
	genFile.P("/* *")
	genFile.P(custom.String())
	genFile.P("*/")
	genFile.P("// * Code generated by protoc-gen-custom. DO NOT EDIT.")
	genFile.P("// * versions:")
	genFile.P("// * - protoc-gen-custom ", GetVersion(debug.ReadBuildInfo))
	genFile.P("// * - protoc                   v", compilerVersion)
	genFile.P("// * source: ", fName)
	genFile.P("")
	genFile.P("package ", g.f.GoPackageName)
	genFile.P("")
	genFile.P("var AllPathToMethodMap = map[string]string{")
	for _, s := range g.protoServices {
		for _, m := range s.Method {
			opts, err := extractAPIOptions(m)
			if err != nil {
				panic(err)
			}
			if opts != nil {
				path := getPathFromHttpRule(opts)
				key := fmt.Sprintf("%s_%s_API", *s.Name, *m.Name)
				genFile.P(key, " : ", "\t", fmt.Sprintf("\"%s\",", path))
			}
		}
	}

	genFile.P("}")
	genFile.P()
	genFile.P("var AllPathToMethodSlice = []string{")
	methodKeys := []string{}
	for _, s := range g.protoServices {
		for _, m := range s.Method {
			opts, err := extractAPIOptions(m)
			if err != nil {
				panic(err)
			}

			if opts != nil {
				key := fmt.Sprintf("%s_%s_API", *s.Name, *m.Name)
				methodKeys = append(methodKeys, key)
			}
		}
	}
	for _, key := range methodKeys {
		genFile.P("\"", key, "\"", ",")
	}
	genFile.P("}")
	genFile.P()
}

// func (g *generator) GenerateCayCu() {
// 	req := g.p.Request
// 	folderStructure := strings.Split(g.f.GeneratedFilenamePrefix, "/")
// 	folderStructure[len(folderStructure)-1] = "cay_cu.pb.go"
// 	filename := strings.Join(folderStructure, "/")

// 	genFile := g.p.NewGeneratedFile(filename, g.f.GoImportPath)
// 	fName := string(g.f.Desc.Name())
// 	custom := figure.NewFigure("custom", "", true)
// 	compilerVersion := "unknown"
// 	if v := req.GetCompilerVersion(); v != nil {
// 		compilerVersion = fmt.Sprintf("%d.%d.%d", v.GetMajor(), v.GetMinor(), v.GetPatch())
// 	}
// 	genFile.P("/* *")
// 	genFile.P(custom.String())
// 	genFile.P("*/")
// 	genFile.P("// * Code generated by protoc-gen-custom. DO NOT EDIT.")
// 	genFile.P("// * versions:")
// 	genFile.P("// * - protoc-gen-custom ", GetVersion(debug.ReadBuildInfo))
// 	genFile.P("// * - protoc                   v", compilerVersion)
// 	genFile.P("// * source: ", fName)
// 	genFile.P("")
// 	genFile.P("package ", g.f.GoPackageName)
// 	genFile.P(fmt.Sprintf("// * %s, %s", folderStructure, fName))
// 	for _, s := range g.f.Services {
// 		genFile.P(fmt.Sprintf("//s.Desc.FullName: %s", s.Desc.FullName()))
// 	}

// }

func (g *generator) GeneratePbMethods() {
	req := g.p.Request
	filename := g.f.GeneratedFilenamePrefix + "_methods.pb.go"
	genFile := g.p.NewGeneratedFile(filename, g.f.GoImportPath)
	fName := string(g.f.Desc.Name())
	custom := figure.NewFigure("custom", "", true)
	compilerVersion := "unknown"
	if v := req.GetCompilerVersion(); v != nil {
		compilerVersion = fmt.Sprintf("%d.%d.%d", v.GetMajor(), v.GetMinor(), v.GetPatch())
	}
	genFile.P("/* *")
	genFile.P(custom.String())
	genFile.P("*/")
	genFile.P("// * Code generated by protoc-gen-custom. DO NOT EDIT.")
	genFile.P("// * versions:")
	genFile.P("// * - protoc-gen-custom ", GetVersion(debug.ReadBuildInfo))
	genFile.P("// * - protoc                   v", compilerVersion)
	genFile.P("// * source: ", fName)
	genFile.P("")
	genFile.P("package ", g.f.GoPackageName)
	genFile.P("const (")
	for _, s := range g.f.Services {
		for _, m := range s.Methods {
			methodName := normalizeFullname(protoreflect.FullName(s.Desc.Name())) + "_" + string(m.Desc.Name())
			genFile.P("\t", methodName, ` = "/`, s.Desc.FullName(), "/", m.Desc.Name(), `"`)
		}
	}

	genFile.P(")")

	for _, s := range g.f.Proto.Service {
		if len(s.Method) > 0 {
			g.GenerateConstApi(genFile, s)
			// 		// g.GenerateMethodToPath(genFile, s)
			// 		// g.GeneratePathToMethod(genFile, s)
		}
	}
}

func (g *generator) GenerateConstApi(genFile *protogen.GeneratedFile, s *descriptorpb.ServiceDescriptorProto) {
	var methodKeys []string
	genFile.P()
	genFile.P("const (")
	for _, m := range s.Method {
		opts, err := extractAPIOptions(m)
		if err != nil {
			panic(err)
		}

		if opts != nil {
			key := fmt.Sprintf("%s_%s_API", *s.Name, *m.Name)
			methodKeys = append(methodKeys, key)

			genFile.P(key, " = ", "\t", fmt.Sprintf("\"%s\"", key))
		}
	}
	genFile.P(")")
	genFile.P()
	genFile.P("var ", *s.Name, "_APIs", " = ", "[]string{")
	for _, key := range methodKeys {
		genFile.P(key, ",")
	}
	genFile.P("}")
	genFile.P()
}

func extractAPIOptions(meth *descriptorpb.MethodDescriptorProto) (*options.HttpRule, error) {
	if meth.Options == nil {
		return nil, nil
	}
	if !proto.HasExtension(meth.Options, options.E_Http) {
		return nil, nil
	}
	ext := proto.GetExtension(meth.Options, options.E_Http)
	opts, ok := ext.(*options.HttpRule)
	if !ok {
		return nil, fmt.Errorf("extension is %T; want an HttpRule", ext)
	}
	return opts, nil
}

func getPathFromHttpRule(opt *options.HttpRule) string {
	var re = regexp.MustCompile(`\{(.*?)\}`)
	switch opt.Pattern.(type) {
	case *options.HttpRule_Get:
		rule := opt.Pattern.(*options.HttpRule_Get)
		return "GET " + re.ReplaceAllString(rule.Get, "*")
	case *options.HttpRule_Post:
		rule := opt.Pattern.(*options.HttpRule_Post)
		return "POST " + re.ReplaceAllString(rule.Post, "*")
	case *options.HttpRule_Put:
		rule := opt.Pattern.(*options.HttpRule_Put)
		return "PUT " + re.ReplaceAllString(rule.Put, "*")
	case *options.HttpRule_Delete:
		rule := opt.Pattern.(*options.HttpRule_Delete)
		return "DELETE " + re.ReplaceAllString(rule.Delete, "*")
	}

	return ""
}
